---
layout: scala-loci
title: ScalaLoci
---

# ScalaLoci

## Research and development of language abstractions for distributed applications in Scala

ScalaLoci is a distributed programming language embedded into Scala.
The language provides a coherent model based on placement types that enables
reasoning about distributed data flows, supporting multiple software
architectures via dedicated language features and abstracting over low-level
communication details and data conversions. ScalaLoci simplifies developing
distributed systems, reduces error-prone communication code and favors early
detection of bugs.


[View code on GitHub](http://github.com/scala-loci/scala-loci)


### Examples

#### P2P Chat

The example logs messages that are sent and received by each participant as a
composition of the data flow from the local UI and from remote chat partners.
In the application, nodes are connected to multiple remote nodes and maintain a
one-to-one chat with each. Users can select any chat to send messages.
The <code>messageSent</code> event is defined as subjective value filtering the
<code>ui.&#x200b;messageTyped</code> messages from the UI for the currently
active chat partner <code>node</code>. The <code>messageLog</code> signal
contains the chat log for the chat between the local peer instance and the
remote <code>node</code> given as parameter. It merges the remote stream for the
chat messages *from the remote instance* <code>node</code> and the local stream
*subjective to the remote instance* <code>node</code> via the <code>||</code>
operator. The chat log is a signal created using <code>list</code>,
which extends the list by an element for each new event occurrence in the
merged stream. The <code>chatLogs</code> signal folds the
<code>remote[Node].&#x200b;joined</code> event stream, which is fired for each
newly connected chat partner, into a signal that contains the chat logs for
every chat partner generated by calling <code>messageLog</code>.

<pre><code>@multitier <span class="keyword">object</span> Chat {
  <span class="keyword">trait</span> Node <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Multiple[Node] }

  <span class="keyword">val</span> ui = <span class="loci-dsl">placed</span>[Node] { UI() }

  <span class="keyword">val</span> messageSent = <span class="loci-dsl">placed</span>[Node].<span class="loci-dsl">sbj</span> { node: Remote[Node] =>
    ui.messageTyped filter { msg => ui.isSelectedChat(node) } }

  <span class="keyword">def</span> messageLog(node: Remote[Node]) = <span class="loci-dsl">placed</span>[Node] {
    ((messageSent <span class="loci-dsl">from</span> node).asLocal || (messageSent <span class="loci-dsl">to</span> node)).list }

  <span class="keyword">val</span> chatLogs = <span class="loci-dsl">placed</span>[Node] {
    <span class="loci-dsl">remote</span>[Node].joined.fold(List.empty[Signal[List[String]]]) {
      <span class="keyword">case</span> (chats, node) => messageLog(node) :: chats } }
}</code></pre>


#### Tweets

The example shows how the operators in a processing pipeline can be placed on
different peers to count the tweets that each author produces in a tweet stream.
The application receives a stream of tweets on the <code>Input</code> peer,
selects those containing the <code>"multitier"</code> string on the
<code>Filter</code> peer, extracts the <code>author</code> for each tweet on the
<code>Mapper</code> peer, and stores a signal with a map counting the tweets
from each author on the <code>Folder</code> peer.

<pre><code>@multitier <span class="keyword">object</span> TweetAuthoring {
  <span class="keyword">trait</span> Input <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Filter] }
  <span class="keyword">trait</span> Filter <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Mapper] <span class="keyword">with</span> Single[Input] }
  <span class="keyword">trait</span> Mapper <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Folder] <span class="keyword">with</span> Single[Filter] } 
  <span class="keyword">trait</span> Folder <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Mapper] }

  <span class="keyword">val</span> tweetStream: Event[Tweet] <span class="loci-dsl">on</span> Input = <span class="loci-dsl">placed</span> { retrieveTweetStream() }

  <span class="keyword">val</span> filtered: Event[Tweet] <span class="loci-dsl">on</span> Filter = <span class="loci-dsl">placed</span> {
    tweetStream.<span class="loci-dsl">asLocal</span> filter { tweet => tweet.hasHashtag("multitier") } }

  <span class="keyword">val</span> mapped: Event[Author] <span class="loci-dsl">on</span> Mapper = <span class="loci-dsl">placed</span> {
    filtered.<span class="loci-dsl">asLocal</span> map { tweet => tweet.author } }

  <span class="keyword">val</span> folded: Signal[Map[Author, Int]] <span class="loci-dsl">on</span> Folder = <span class="loci-dsl">placed</span> {
    mapped.<span class="loci-dsl">asLocal</span>.fold(Map.empty[Author, Int].withDefaultValue(0)) {
      (map, author) => map.updated(map(author) + 1) } }
}</code></pre>


#### E-Mail Application

The example shows a client–server e-mail application. The server stores a list
of e-mails. The client can request the e-mails received in the *n* previous days
containing a given word. The client user interface displays the e-mails broken
into several pages. If the word is not in the current page, the user is informed.

The definition of <code>word</code> of type
<code>Signal[String]<span>&thinsp;</span>on<span>&thinsp;</span>Client</code>
defines a signal carrying strings placed on the <code>Client</code> peer. Thanks
to multitier reactives, the client-side signal <code>inCurrentPage</code> is
defined by the composition of the local client-side signal <code>word</code> and
the remote server-side signal <code>filteredEmails</code>. The latter is defined
as a composition of a local signal and two remote signals.

<pre><code>@multitier <span class="keyword">object</span> MailApp {
  <span class="keyword">trait</span> Server <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Client] }
  <span class="keyword">trait</span> Client <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Server] }

  <span class="keyword">val</span> word: Signal[String] <span class="loci-dsl">on</span> Client = <span class="loci-dsl">placed</span> { <span class="comment">/* GUI input */</span> }
  <span class="keyword">val</span> days: Signal[Int] <span class="loci-dsl">on</span> Client = <span class="loci-dsl">placed</span> { <span class="comment">/* GUI input */</span> }

  <span class="keyword">val</span> allEmails: Signal[List[Email]] <span class="loci-dsl">localOn</span> Server = <span class="loci-dsl">placed</span> {
    <span class="comment">/* e-mail collection */</span> }

  <span class="keyword">val</span> filteredEmails: Signal[List[Email]] <span class="loci-dsl">on</span> Server = <span class="loci-dsl">placed</span> {
    Signal {
      allEmails() filter { email =>
        (email.date < Date.today() - days.<span class="loci-dsl">asLocal</span>()) &amp;&amp;
        (email.text contains word.<span class="loci-dsl">asLocal</span>()) } } }

  <span class="keyword">val</span> inCurrentPage: Boolean <span class="loci-dsl">localOn</span> Client = <span class="loci-dsl">placed</span> {
    Signal { isCurrentFirstPage(word(), filteredEmails.<span class="loci-dsl">asLocal</span>()) }
}</code></pre>


#### Master–worker

The example shows a ScalaLoci implementation of the master–worker pattern where
a master node dispatches tasks – double a number, for simplicity – to workers.
The <code>taskStream</code> on the master carries the tasks as events.
The <code>assocs</code> signal contains the assignments of workers to tasks.
It folds over the
<code>taskStream<span>&thinsp;</span>||<span>&thinsp;</span>taskResult.&#x200b;asLocalFromAllSeq</code>
event stream that fires for every new task (<code>taskStream</code>) and every
completed task (<code>taskResult.&#x200b;asLocalFromAllSeq</code>).
The <code>assignTasks</code> method assigns a worker to the new task
(<code>taskAssocs</code>), or enqueues the task if no worker is free
(<code>taskQueue</code>) based on the folded event (<code>taskChanged</code>)
and the currently connected worker instances
(<code>remote[Worker].&#x200b;connected</code>). The <code>deployTask</code>
event subjectively provides every worker instance with the task it is assigned.
Workers provide the result in the <code>taskResult</code> event stream which the
master aggregates into the <code>result</code> signal. The signal is updated for
every event to contain the sum of all values carried by the events.

<pre><code>@multitier <span class="keyword">object</span> MasterWorker {
  <span class="keyword">trait</span> Master <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Multiple[Worker] }
  <span class="keyword">trait</span> Worker <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Master] }

  <span class="keyword">class</span> Task(v: Int) { <span class="keyword">def</span> exec: Int = 2 * v }

  <span class="keyword">val</span> taskStream: Event[Task] <span class="loci-dsl">localOn</span> Master = Event[Task]
    <span class="comment">// to add tasks: `taskStream.fire(Task(42))`</span>

  <span class="keyword">val</span> assocs: Signal[Map[Remote[Worker], Task]] <span class="loci-dsl">localOn</span> Master = <span class="loci-dsl">placed</span> {
    (taskStream || taskResult.<span class="loci-dsl">asLocalFromAllSeq</span>)
      .fold(Map.empty[Remote[Worker], Task], List.empty[Task])
       { (taskAssocs, taskQueue, taskChanged) =>
         assignTasks(taskAssocs, taskQueue, taskChanged, <span class="loci-dsl">remote</span>[Worker].<span class="loci-dsl">connected</span>) } }

  <span class="keyword">val</span> deployTask = <span class="loci-dsl">placed</span>[Master].<span class="loci-dsl">sbj</span> { worker: Remote[Worker] =>           <span class="comment">// Event[Task]</span>
    Signal{ assocs().get(worker) }.changed }
  <span class="keyword">val</span> taskResult = <span class="loci-dsl">placed</span>[Worker] {                                         <span class="comment">// Event[Int]</span>
    deployTask.<span class="loci-dsl">asLocal</span> collect { <span class="keyword">case</span> Some(task) => task.exec } }
  <span class="keyword">val</span> result = <span class="loci-dsl">placed</span>[Master] {                                             <span class="comment">// Signal[Int]</span>
    taskResult.<span class="loci-dsl">asLocalFromAllSeq</span>.fold(0){ <span class="keyword">case</span> (acc, (worker, result)) => acc + result } }
}</code></pre>


#### Token Ring

The example models a token ring, where every node in the ring can send a token
for another node. Multiple tokens can circulate in the ring simultaneously until
they reach their destination. Every node has exactly one predecessor and one
successor. We define a <code>Prev</code> and a <code>Next</code> peer and
specify that a <code>Node</code> itself is both a predecessor and a successor
and has a single tie to its own predecessor and a single tie to its successor.
Tokens are passed from predecessors to successors, hence nodes access the tokens
sent from their predecessor. For this reason, values are placed on the
<code>Prev</code> peer. Every node has a unique ID. The <code>sendToken</code>
event sends a token along the ring to another peer instance. The
<code>recv</code> event stream provides the data received by each peer instance.
Each node fires <code>recv</code> when it receives a token addressed to itself,
i.e., when the <code>receiver</code> equals the node ID and forwards other
tokens. The expression
<code>sent.&#x200b;asLocal<span>&thinsp;</span>\<span>&thinsp;</span>recv</code>
evaluates to an event stream of all events from
<code>sent.&#x200b;asLocal</code> for which <code>recv</code> does not fire.
Merging such stream (of forwarded tokens) with the <code>sendToken</code> stream
injects both new and forwarded tokens into the ring.

<pre><code>@multitier <span class="keyword">object</span> TokenRing {
  <span class="keyword">trait</span> Prev <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Prev] }
  <span class="keyword">trait</span> Next <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Next] }
  <span class="keyword">trait</span> Node <span class="keyword">extends</span> Prev <span class="keyword">with</span> Next { <span class="keyword">type</span> Tie &lt;: Single[Prev] <span class="keyword">with</span> Single[Next] }

  <span class="keyword">val</span> id: Id <span class="loci-dsl">on</span> Prev = Id()

  <span class="keyword">val</span> sendToken: Event[(Id, Token)] <span class="loci-dsl">localOn</span> Prev = Event[(Id, Token)]()

  <span class="keyword">val</span> recv: Event[Token] <span class="loci-dsl">localOn</span> Prev = <span class="loci-dsl">placed</span> {
    sent.<span class="loci-dsl">asLocal</span> collect { <span class="keyword">case</span> (receiver, token) <span class="keyword">if</span> receiver == id => token } }

  <span class="keyword">val</span> sent: Event[(Id, Token)] <span class="loci-dsl">on</span> Prev = <span class="loci-dsl">placed</span> { (sent.<span class="loci-dsl">asLocal</span> \ recv) || sendToken }
}</code></pre>
