---
layout: scala-loci
title: ScalaLoci
---

# ScalaLoci

## Research and development of language abstractions for distributed applications in Scala

ScalaLoci tames the complexity of developing distributed applications via
specialized programming language support. The multitier approach provides a
coherent model to reason about data flows, otherwise scattered across multiple
modules, support multiple software architectures through dedicated language
features, and abstract over low-level details such as network communication
protocols and data conversions. ScalaLoci automatically generates communication
code that would be otherwise manually written and prone to errors, favoring
early detection of bugs, and introducing means to easily migrate applications
among different platforms and communication mechanisms.


[View code on GitHub](http://github.com/scala-loci/scala-loci)


### Examples

#### Chat

The example logs messages that are sent and received by each participant as a
composition of the data flow from the local UI and from remote chat partners.
In the application, nodes are connected to multiple remote nodes and maintain a
one-to-one chat with each. Users can select any chat to send messages.  The
`messageSent` event is defined as subjective value filtering  the
`ui.messageTyped` messages from the UI for the currently active chat partner
`node`. The `messageLog` signal contains the chat log for the chat between the
local peer instance and the remote `node` given as parameter. It merges the
remote stream for the chat messages *from the remote instance* `node` and the
local stream *subjective to the remote instance* `node` via the `||` operator.
The chat log is a signal created using `list`,  which extends the list by an
element for each new event occurrence in the merged stream. The `chatLogs`
signal folds the `remote[Node].joined` event stream, which is fired for each
newly connected chat partner, into a signal that contains the chat logs for
every chat partner generated by calling `messageLog`.

<pre><code>@multitier <span class="keyword">object</span> Chat {
  <span class="keyword">trait</span> Node <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie = Multiple[Node] }

  <span class="keyword">val</span> ui = <span class="loci-dsl">placed</span>[Node] { UI() }

  <span class="keyword">val</span> messageSent = <span class="loci-dsl">placed</span>[Node].<span class="loci-dsl">sbj</span> { node: Remote[Node] =>
    ui.messageTyped filter { msg => ui.isSelectedChat(node) } }

  <span class="keyword">def</span> messageLog(node: Remote[Node]) = <span class="loci-dsl">placed</span>[Node] {
    ((messageSent <span class="loci-dsl">from</span> node).asLocal || (messageSent <span class="loci-dsl">to</span> node)).list }

  <span class="keyword">val</span> chatLogs = <span class="loci-dsl">placed</span>[Node] {
    <span class="loci-dsl">remote</span>[Node].joined.fold(List.empty[Signal[List[String]]]) {
      <span class="keyword">case</span> (chats, node) => messageLog(node) :: chats } }
}</code></pre>


#### Tweets

The example shows how the operators in a processing pipeline can be placed to
different peers to count the tweets that each  author produces in a tweet
stream. The application receives a stream of tweets on the `Input` peer, selects
those containing the `"multitier"` string on the `Filter` peer, extracts the
`author` from each peer on the `Mapper` peer, and stores a signal with a map
that counts the tweets from each author on the `Folder` peer.

<pre><code>@multitier <span class="keyword">object</span> TweetAuthoring {
  <span class="keyword">trait</span> Input <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Filter] }
  <span class="keyword">trait</span> Filter <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Mapper] <span class="keyword">with</span> Single[Input] }
  <span class="keyword">trait</span> Mapper <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Folder] <span class="keyword">with</span> Single[Filter] } 
  <span class="keyword">trait</span> Folder <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Mapper] }

  <span class="keyword">val</span> tweetStream: Event[Tweet] <span class="loci-dsl">on</span> Input = <span class="loci-dsl">placed</span> { retrieveTweetStream() }

  <span class="keyword">val</span> filtered: Event[Tweet] <span class="loci-dsl">on</span> Filter = <span class="loci-dsl">placed</span> {
    tweetStream.asLocal.filter { tweet => tweet.hasHashtag("multitier") } }

  <span class="keyword">val</span> mapped: Event[Author] <span class="loci-dsl">on</span> Mapper = <span class="loci-dsl">placed</span> {
    filtered.asLocal.map { tweet => tweet.author } }

  <span class="keyword">val</span> folded: Signal[Map[Author, Int]] <span class="loci-dsl">on</span> Folder = <span class="loci-dsl">placed</span> {
    mapped.<span class="loci-dsl">asLocal</span>.fold(Map.empty[Author, Int].withDefaultValue(0)) {
      (map, author) => map.updated(map(author) + 1) } }
}</code></pre>


#### E-Mail Application

The example shows a client–server e-mail  application. The server stores a list
of e-mails. The client can request the e-mails received in the *n* previous days
containing a given word. The client user interface displays the e-mails  broken
into several pages and highlights the searched word  in the currently displayed
page (for brevity, the UI is omitted).   If the word is not in the current page,
the user is informed.

The definition of `word` of type `Signal[String]on Client` defines a signal
carrying strings placed on the `Client` peer. Thanks to multitier reactives, the
client-side signal `inCurrentPage` is defined by the composition of the local
client-side signal `word` and the remote server-side signal `filteredEmails`.
The latter is defined as a composition of a local signal and two remote signals.

<pre><code>@multitier <span class="keyword">object</span> MailApp {
  <span class="keyword">trait</span> Server <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie = Single[Client] }
  <span class="keyword">trait</span> Client <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie = Single[Server] }

  <span class="keyword">val</span> word: Signal[String] <span class="loci-dsl">on</span> Client = <span class="loci-dsl">placed</span> { <span class="comment">/* GUI input */</span> }
  <span class="keyword">val</span> days: Signal[Int] <span class="loci-dsl">on</span> Client = <span class="loci-dsl">placed</span> { <span class="comment">/* GUI input */</span> }

  <span class="keyword">val</span> inCurrentPage: Boolean <span class="loci-dsl">localOn</span> Client = <span class="loci-dsl">placed</span> {
    Signal { isCurrentFirstPage(word(), filteredEmails.<span class="loci-dsl">asLocal</span>()) }

  <span class="keyword">val</span> allEmails: Signal[List[Email]] <span class="loci-dsl">localOn</span> Server = <span class="loci-dsl">placed</span> {
    <span class="comment">/* e-mail collection */</span> }

  <span class="keyword">val</span> filteredEmails: Signal[List[Email]] <span class="loci-dsl">on</span> Server = <span class="loci-dsl">placed</span> {
    Signal {
      allEmails() filter { email =>
        (email.date < Date.today() - days.<span class="loci-dsl">asLocal</span>()) &amp;&amp;
        (email.text contains word.<span class="loci-dsl">asLocal</span>()) } } }
}</code></pre>


#### Master–worker

The example shows a ScalaLoci implementation of the master–worker pattern where
a master node dispatches tasks  – double a number, for simplicity – to workers.
The `taskStream` on the master carries the tasks as events.  The stream of tasks
is mapped to a stream of results. Every task is executed on a randomly selected
worker instance via an egg. The results are returned asynchronously as futures
using `asLocal` and folded into a signal on the master. The signal is updated
for every event to contain the  sum of all values carried by the events. The
signal of type `Signal[Future[Int]]` is flattened into a `Signal[Int]`
converting from futures to reactive values.

<pre><code>@multitier <span class="keyword">object</span> MasterWorker {
  <span class="keyword">trait</span> Master <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Multiple[Worker] }
  <span class="keyword">trait</span> Worker <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Master] }

  <span class="keyword">class</span> Task(v: Int) { <span class="keyword">def</span> exec: Int = 2 * v }

  <span class="keyword">val</span> taskStream: Event[Task] <span class="loci-dsl">localOn</span> Master = Event[Task]
    <span class="comment">// to add tasks: `taskStream.fire(Task(42))`</span>

  <span class="keyword">val</span> results: Signal[Int] <span class="loci-dsl">localOn</span> Master = <span class="loci-dsl">placed</span> {
    <span class="keyword">def</span> nextWorker: Remote[Worker] = Random.shuffle(<span class="loci-dsl">remote</span>[Worker].<span class="loci-dsl">connected</span>.now).head
    taskStream
      .map { task =>
        <span class="loci-dsl">egg</span>.<span class="loci-dsl">on</span>(nextWorker).<span class="loci-dsl">capture</span>(task){ task.exec }.<span class="loci-dsl">asLocal</span>: Future[Int] }  <span class="comment">// Event[Future[Int]]</span>
      .fold(Future.successful(0)) { (acc, x) => acc + x: Future[Int] }        <span class="comment">// Signal[Future[Int]]</span>
      .map { sum => Signals.fromFuture(sum): Signal[Int] }.flatten }          <span class="comment">// Signal[Int]</span>
}</code></pre>


#### Token Ring

The example models a token ring, where every node in the ring can send a token
for another node. We allow multiple tokens to circulate in the ring
simultaneously until they reach their destination. Every node has exactly one
predecessor and one successor. We define a `Prev` and a `Next` peer  and specify
that a `Node` itself is both a predecessor and a successor and has a single tie
to its own predecessor and a single tie to its successor. Using *multiple* ties
would allow nodes to join and leave updating the ring dynamically but is not
discussed further. Tokens are passed from predecessors to successors, hence
nodes access the tokens sent from their predecessor. For this reason, values are
placed on the `Prev` peer. Every node has a unique ID.  The `sendToken` event
sends a token along the ring to another peer instance. The `recv` event stream
provides the data  received by each peer instance. Each node fires the `recv`
when it received a token addressed to itself, i.e., when the `receiver` equals
the node ID – other tokens are forwarded. The expression
`sent.asLocal`&thinsp;`\`&thinsp;`recv` evaluates to an event stream of all
events from `sent.asLocal` for which `recv` does not fire. Merging such stream
(of forwarded tokens) with the `sendContent` stream injects both new and
forwarded  tokens into the ring.

<pre><code>@multitier <span class="keyword">object</span> TokenRing {
  <span class="keyword">trait</span> Prev <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Prev] }
  <span class="keyword">trait</span> Next <span class="keyword">extends</span> Peer { <span class="keyword">type</span> Tie &lt;: Single[Next] }
  <span class="keyword">trait</span> Node <span class="keyword">extends</span> Prev <span class="keyword">with</span> Next { <span class="keyword">type</span> Tie &lt;: Single[Prev] <span class="keyword">with</span> Single[Next] }

  <span class="keyword">val</span> id: Id <span class="loci-dsl">on</span> Prev = Id()
  <span class="keyword">val</span> sendToken: Event[(Id, Token)] <span class="loci-dsl">localOn</span> Prev = Event[(Id, Token)]

  <span class="keyword">val</span> recv: Event[Token] <span class="loci-dsl">localOn</span> Prev = <span class="loci-dsl">placed</span> {
    sent.<span class="loci-dsl">asLocal</span> collect { <span class="keyword">case</span> (receiver, token) <span class="keyword">if</span> receiver == id => token } }

  <span class="keyword">val</span> sent: Event[(Id, Token)] <span class="loci-dsl">on</span> Prev = <span class="loci-dsl">placed</span> { (sent.<span class="loci-dsl">asLocal</span> \ recv) || sendToken }
}</code></pre>
